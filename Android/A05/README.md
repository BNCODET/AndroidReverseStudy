## 1.1 DES

### 1.1.1 简介

- Data encrypt standard 数据加密标准  
- 入参: 64比特(8个字节、16个16进制数)
- key: 64比特(8个字节、16个16进制数)
- 结果:  64比特(8个字节、16个16进制数)
- DES分两部分：明文的处理以及密钥的编排
- 二进制流处理

### 1.1.2 手算DES

- 前置

   input: 0123456789abcdef (hex)

   key: 133457799bbcdff1(hex)

   output: 85e813540f0ab405 (hex)

   模式: ECB

- 第0步：初始置换

  初始置换表:

  ```python
  PI =   [58, 50, 42, 34, 26, 18, 10, 2,
  	      60, 52, 44, 36, 28, 20, 12, 4,
  	      62, 54, 46, 38, 30, 22, 14, 6,
  	      64, 56, 48, 40, 32, 24, 16, 8,
  	      57, 49, 41, 33, 25, 17, 9, 1,
  	      59, 51, 43, 35, 27, 19, 11, 3,
  	      61, 53, 45, 37, 29, 21, 13, 5,
  	      63, 55, 47, 39, 31, 23, 15, 7]
  ```

  需要对`input`重新排列。根据PI表的索引指示，对明文重新排列，58就是找明文第58个

  > 注：数的时候input从1开始不是0, 看PI表的顺序为从左到右然后从上至下）

  input的二进制表现形式为：`00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111`

  置换后的结果为：`11001100 00000000 11001100 11111111 11110000 10101010 11110000 10101010`

- 第一步：密钥的编排

  密钥的二进制表现形式为：`00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001`

  使用PC1(置换选择表1)，只有56个位置，用法同上。des密钥一共64位，只有56位被使用。

  ```python
   CP_1 = [57, 49, 41, 33, 25, 17, 9,
          1, 58, 50, 42, 34, 26, 18,
          10, 2, 59, 51, 43, 35, 27,
          19, 11, 3, 60, 52, 44, 36,
          63, 55, 47, 39, 31, 23, 15,
          7, 62, 54, 46, 38, 30, 22,
          14, 6, 61, 53, 45, 37, 29,
          21, 13, 5, 28, 20, 12, 4]
  ```

  置换后的结果为：`1111000 0110011 0010101 0101111 0101010 1011001 1001111 0001111` 

  > 注：此时由64为变成了56位

  ---------------------------------------------------------------

  平等拆成两块：

    Left0：`1111000 0110011 0010101 0101111`
    Right0：`0101010 1011001 1001111 0001111`

  然后进行循环左移，进行一共16轮运算：

  ​	SHIFT = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1] 

  L1:   对Left0左移1位, 位数 = SHIFT[0] = 1 得到 `1110000 1100110 0101010 1011111`

  R1 :  对right左移1位, 位数 = SHIFT[0] = 1 得到 `1010101 0110011 0011110 0011110`

  然后进行拼接：

  ​	L1 + R1:1110000 1100110 0101010 1011111 1010101 0110011 0011110 0011110

  使用PC2(置换选择表2)进行置换，只有48个位置

  ```python
  CP_2 = [14, 17, 11, 24, 1, 5, 3, 28,
          15, 6, 21, 10, 23, 19, 12, 4,
          26, 8, 16, 7, 27, 20, 13, 2,
          41, 52, 31, 37, 47, 55, 30, 40,
          51, 45, 33, 48, 44, 49, 39, 56,
          34, 53, 46, 42, 50, 36, 29, 32]
  ```

  L1R1经过置cp_2置换后的结果为：
     k1: 00011011 00000010 11101111 11111100 01110000 01110010 , 得到了第一个子密钥

  > 注：此时由56为变成了48位

  ---------------------------

​       L2:  对L1进行左移SHIFT[1]位, 得到 110000 1100110 0101010 10111111
​       R2: 对R1进行左移SHIFT[1]位, 得到 010101 0110011 0011110 00111101

​       append后得到L2R2与CP_2继续置换生成k2

​       循环往复直到生成k16，16轮的k/子密钥

- 第二步：明文的处理

  上文已经对明文的重排并得到了结果：`11001100 00000000 11001100 11111111 11110000 10101010 11110000 10101010`并得到了了`16`个子密钥

  把重排的结果分两半
   L0: `11001100 00000000 11001100 11111111`

   R0: `11110000 10101010 11110000 10101010`

   L1: R0 (总是上一步的R)

   R1: L0 + F(R0, K1)   可以看到得到Rn的公式就是: Rn = Ln -1 + F(Rn -1, kn）, 注: 此刻的+号为异或运算

  -------------------

   F 函数中 第一步：

   	R0 32位 扩展到48位，

  

  

  

  